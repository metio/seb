<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Interoperability on Sebastian Hoß</title><link>https://seb.xn--ho-hia.de/tags/interoperability/</link><description>Recent content in Interoperability on Sebastian Hoß</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 06 Jan 2023 17:32:06 +0100</lastBuildDate><atom:link href="https://seb.xn--ho-hia.de/tags/interoperability/index.xml" rel="self" type="application/rss+xml"/><item><title>Clojure Java Interoperability</title><link>https://seb.xn--ho-hia.de/posts/clojure-java-interoperability/</link><pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate><guid>https://seb.xn--ho-hia.de/posts/clojure-java-interoperability/</guid><description>Clojure has several forms and macros to call Java code. However, calling Clojure code from Java is not always so straightforward. The following post shows the different options currently available.
Using gen-class Clojure code can be compiled to standard JVM bytecode using gen-class.
Adding static modifiers Clojure imposes the concept of immutability. As such Clojure functions are/should be void of any state or side effects and only operate on the given input.</description></item></channel></rss>